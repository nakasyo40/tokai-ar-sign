<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TOKAI AR - 最新読み込み対応</title>
<style>
body {
  margin: 0;
  background: black;
  font-family: sans-serif;
  overflow: hidden;
}

video {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  z-index: 1;
  pointer-events: none;
}

#sign {
  position: fixed;
  bottom: 20px;
  left: 20px;
  width: 150px;
  z-index: 10;
  touch-action: none;
}

button {
  position: fixed;
  width: 180px;
  padding: 14px 0;
  font-size: 16px;
  border-radius: 30px;
  border: none;
  background: #0066cc;
  color: white;
  cursor: pointer;
  z-index: 9999;
}

#startBtn { top: 40%; left: 50%; margin-left: -90px; }
#shutterBtn { bottom: 20px; left: 50%; margin-left: -90px; display: none; }
#switchBtn { bottom: 70px; left: 50%; margin-left: -90px; display: none; }

canvas { display: none; }
</style>
</head>
<body>

<button id="startBtn">カメラ起動</button>
<button id="shutterBtn">撮影する</button>
<button id="switchBtn">カメラ切替</button>

<video id="video" autoplay playsinline></video>
<img id="sign">
<canvas id="canvas"></canvas>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const startBtn = document.getElementById("startBtn");
  const shutterBtn = document.getElementById("shutterBtn");
  const switchBtn = document.getElementById("switchBtn");
  const video = document.getElementById("video");
  const sign = document.getElementById("sign");
  const canvas = document.getElementById("canvas");

  // キャッシュバスター生成
  const cacheVer = Date.now();

  // 画像に自動でクエリ付与
  sign.src = "sign.png?ver=" + cacheVer;

  let currentFacing = "environment"; // デフォルトアウトカメラ
  let stream;

  async function startCamera(facingMode) {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: facingMode } }
      });
      video.srcObject = stream;
    } catch (err) {
      alert("カメラにアクセスできませんでした: " + err);
    }
  }

  startBtn.addEventListener("click", async () => {
    await startCamera(currentFacing);
    startBtn.style.display = "none";
    shutterBtn.style.display = "block";
    switchBtn.style.display = "block";
  });

  switchBtn.addEventListener("click", async () => {
    currentFacing = currentFacing === "environment" ? "user" : "environment";
    await startCamera(currentFacing);
  });

  shutterBtn.addEventListener("click", () => {
    const w = video.videoWidth;
    const h = video.videoHeight;
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");

    ctx.drawImage(video, 0, 0, w, h);

    const rect = sign.getBoundingClientRect();
    ctx.drawImage(
      sign,
      rect.left * w / window.innerWidth,
      rect.top * h / window.innerHeight,
      rect.width * w / window.innerWidth,
      rect.height * h / window.innerHeight
    );

    const a = document.createElement("a");
    a.href = canvas.toDataURL("image/png");

    const now = new Date();
    const timestamp = now.getFullYear().toString() +
                      (now.getMonth()+1).toString().padStart(2,'0') +
                      now.getDate().toString().padStart(2,'0') + "_" +
                      now.getHours().toString().padStart(2,'0') +
                      now.getMinutes().toString().padStart(2,'0') +
                      now.getSeconds().toString().padStart(2,'0') +
                      now.getMilliseconds().toString().padStart(3,'0');
    a.download = `tokai-ar-photo_${timestamp}.png`;
    a.click();
  });

  // ピンチで拡大縮小
  let initialDistance = 0;
  let initialWidth = 0;

  sign.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      initialDistance = Math.hypot(dx, dy);
      initialWidth = sign.offsetWidth;
    }
  });

  sign.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const newDistance = Math.hypot(dx, dy);
      const scale = newDistance / initialDistance;
      sign.style.width = initialWidth * scale + 'px';
      e.preventDefault();
    }
  });

  // URLがクエリなしなら自動でクエリ付与して再読み込み
  if (!window.location.search.includes("ver=")) {
    const newUrl = window.location.href.split('?')[0] + "?ver=" + cacheVer;
    window.location.replace(newUrl);
  }

});
</script>

</body>
</html>
